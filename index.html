<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Interactive Molecular Analogy</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<link rel="stylesheet" href="style.css">
</head>
<body>
	<div id="container3D"></div>

	<div id="draggable-panel-container" class="draggable-panel-container">
		<button id="toggleUiBtn" class="absolute -top-4 right-1/2 translate-x-1/2 bg-blue-600 rounded-full p-2 shadow-lg hover:bg-blue-500 transition">
			 <svg id="ui-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" /></svg>
		</button>
		<div id="ui-panel" class="ui-panel control-container">
			<div id="drag-handle" class="drag-handle">
				<h1 class="text-xl font-bold text-white">Computational Analogy: <span id="moleculeName">H₂O</span></h1>
			</div>
			<div class="flex justify-center items-center gap-4 mt-4">
				<button id="formBtn" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg transition duration-300">Form Molecule</button>
				<button id="resetBtn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg transition duration-300">Reset</button>
			</div>
			<div id="angleDisplay" class="mt-4 text-lg font-mono text-green-400 h-6 text-center"></div>
			<hr class="border-gray-600 my-4">

			<div class="mb-4">
				<label for="moleculeSelector" class="block text-sm font-medium text-gray-300 mb-2">Select Molecule:</label>
				<select id="moleculeSelector" class="block w-full bg-gray-700 border-gray-600 text-white rounded-md shadow-sm focus:border-blue-500 focus:ring focus:ring-blue-500 focus:ring-opacity-50 p-2">
					<option value="H2O">H₂O (Water)</option>
					<option value="CH4">CH₄ (Methane)</option>
					<option value="NH3">NH₃ (Ammonia)</option>
					<option value="CO2">CO₂ (Carbon Dioxide)</option>
					<option value="C2H4">C₂H₄ (Ethylene)</option>
					<option value="HCN">HCN (Hydrogen Cyanide)</option>
					<option value="SO2">SO₂ (Sulfur Dioxide)</option>
					<option value="H2SO4">H₂SO₄ (Sulfuric Acid)</option>
					<option value="CH3COOH">CH₃COOH (Acetic Acid)</option>
					<option value="C6H6">C₆H₆ (Benzene)</option>
					<option value="C2H5OH">C₂H₅OH (Ethanol)</option>
					<option value="NH2CONH2">NH₂CONH₂ (Urea)</option>
					<option value="Custom">Custom Molecule</option>
				</select>
			</div>
			
			<div class="space-y-4">
				<label class="toggle-label text-sm text-gray-300"><span>Show Nuclei</span><input type="checkbox" id="showNucleiToggle" class="toggle-checkbox" checked><span class="toggle-switch"></span></label>
				<label class="toggle-label text-sm text-gray-300"><span>Visualize Bonds</span><input type="checkbox" id="showBondsToggle" class="toggle-checkbox" checked><span class="toggle-switch"></span></label>
				<div>
					 <label class="slider-label text-sm text-gray-300 mb-2"><span>Particle Density</span><span id="particleCountLabel">15000</span></label>
					 <input type="range" id="particleCountSlider" min="1000" max="30000" value="15000" step="1000">
				</div>
				<div>
					 <label class="slider-label text-sm text-gray-300 mb-2"><span>Init Box Size</span><span id="boxSizeLabel">4</span></label>
					 <input type="range" id="boxSizeSlider" min="0.1" max="10" value="4" step="0.1">
				</div>
				<div>
					 <label class="slider-label text-sm text-gray-300 mb-2"><span>Particle Damping</span><span id="particleDampingLabel">0.92</span></label>
					 <input type="range" id="particleDampingSlider" min="0.8" max="0.99" value="0.92" step="0.01">
					 <p class="text-xs text-gray-500 text-center mt-1">Changes require simulation reset.</p>
				</div>
				<div>
					 <label class="slider-label text-sm text-gray-300 mb-2"><span>Attractor Damping</span><span id="attractorDampingLabel">0.90</span></label>
					 <input type="range" id="attractorDampingSlider" min="0.8" max="0.99" value="0.90" step="0.01">
					 <p class="text-xs text-gray-500 text-center mt-1">Changes require simulation reset.</p>
				</div>
				<div>
					<label class="slider-label text-sm text-gray-300 mb-2"><span>Quantum Constant (k)</span><span id="quantumConstantLabel">5.0</span></label>
					<input type="range" id="quantumConstantSlider" min="1.0" max="10.0" value="5.0" step="0.1">
					 <p class="text-xs text-gray-500 text-center mt-1">Changes require simulation reset.</p>
				</div>
				<div>
					<label class="slider-label text-sm text-gray-300 mb-2"><span>Repulsion Force</span><span id="repulsionForceLabel">0.0008</span></label>
					<input type="range" id="repulsionForceSlider" min="0.0001" max="0.005" value="0.0008" step="0.0001">
					 <p class="text-xs text-gray-500 text-center mt-1">Changes require simulation reset.</p>
				</div>
				<div>
					<label class="slider-label text-sm text-gray-300 mb-2"><span>Lone Pair Repulsion Multiplier</span><span id="lpRepulsionMultiplierLabel">2.25</span></label>
					<input type="range" id="lpRepulsionMultiplierSlider" min="1.0" max="5.0" value="2.25" step="0.05">
					 <p class="text-xs text-gray-500 text-center mt-1">Changes require simulation reset.</p>
				</div>
				<div>
					<label class="slider-label text-sm text-gray-300 mb-2"><span>Core Electron Count (O-atom)</span><span id="coreElectronCountLabel">200</span></label>
					<input type="range" id="coreElectronCountSlider" min="0" max="1000" value="200" step="10">
					<p class="text-xs text-gray-500 text-center mt-1">Affects number of red particles.</p>
				</div>
				
				<hr class="border-gray-600 my-4">

				<div id="customMoleculeControls" class="mt-6 hidden">
					<h3 class="text-md font-bold text-white mb-3">Custom Molecule Settings</h3>
					<div id="customAttractorInputs" class="space-y-3">
						<!-- Custom attractor inputs will be generated here -->
					</div>
					<button id="addAttractorBtn" class="mt-4 w-full bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Add Attractor</button>
					<div class="input-group mt-4">
						<label for="customLonePairCount">Lone Pair Count</label>
						<input type="number" id="customLonePairCount" value="0" min="0" max="4">
					</div>
				
				<hr class="border-gray-600 my-4">
				</div>
				
				<h3 class="text-md font-bold text-white mb-2">Colors:</h3>
				<div class="grid grid-cols-3 gap-4">
					<div class="input-group">
						<label for="valenceColorPicker">Valence Electrons</label>
						<input type="color" id="valenceColorPicker" value="#7df9ff">
					</div>
					<div class="input-group">
						<label for="coreColorPicker">Core Electrons</label>
						<input type="color" id="coreColorPicker" value="#ff4136">
					</div>
					<div class="input-group">
						<label for="bondColorPicker">Bonding Electrons</label>
						<input type="color" id="bondColorPicker" value="#fef08a">
					</div>
				</div>

				<div id="customMoleculeControls" class="mt-6 hidden">
					<h3 class="text-md font-bold text-white mb-3">Custom Molecule Settings</h3>
					<div id="customAttractorInputs" class="space-y-3">
						<!-- Custom attractor inputs will be generated here -->
					</div>
					<button id="addAttractorBtn" class="mt-4 w-full bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Add Attractor</button>
					<div class="input-group mt-4">
						<label for="customLonePairCount">Lone Pair Count</label>
						<input type="number" id="customLonePairCount" value="0" min="0" max="4">
					</div>
				</div>
			</div>
			<div class="mt-8 text-center text-gray-400 text-xs">
				<p class="font-medium">&copy; 2025. Project licensed under MIT. Designed by 
					<a href="https://github.com/CyberMagician/ComputationalChemistry/" target="_blank" class="text-blue-400 hover:text-blue-300">&#x2197;CyberMagician</a> (original author) and 
					<a href="https://wartets.github.io/Wartets/" target="_blank" class="text-blue-400 hover:text-blue-300">&#x2197;Wartets</a> (forker, 
					<wbr>see more projects on <a href="https://github.com/wartets" target="_blank" class="text-blue-400 hover:text-blue-300">&#x2197;GitHub</a>).
				</p>
			</div>
		</div>
	</div>

	<script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/" } }</script>
	<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { DragControls } from 'three/addons/controls/DragControls.js';

let scene, camera, renderer, orbitControls, dragControls;
let particles, particleSystem, velocities, particleColors;
let attractors = [], lonePairs = [];
let attractorMeshes = [];
let simulationActive = false;
let userIsDragging = false;
let showBonds = true;

// Default & Customizable Parameters
let NUM_PARTICLES = 15000;
let LENGHT = 4;
let CORE_ELECTRON_COUNT = 200; // Number of particles colored as core electrons (e.g., for Oxygen's 1s2)
let PARTICLE_DAMPING = 0.92;
let ATTRACTOR_DAMPING = 0.90;
let QUANTUM_CONSTANT_K = 5.0; // Controls the 'frequency' of the wave function cosine term
let REPULSION_FORCE_MAGNITUDE = 0.0008; // Base repulsion between nuclei/lone pairs
let LONE_PAIR_REPULSION_MULTIPLIER = 2.25; // How much stronger lone pairs repel other nuclei

let VALENCE_COLOR = new THREE.Color(0x7df9ff); // Cyan
let CORE_COLOR = new THREE.Color(0xff4136); // Red
let BOND_COLOR = new THREE.Color(0xfef08a); // Yellow

// Molecular Configurations
const MOLECULE_CONFIGS = {
	"H2O": {
		name: "H₂O",
		attractorData: [
			{ name: 'O', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: false },
			{ name: 'H1', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H2', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }
		],
		lonePairCount: 2,
		initialPositions: [
			new THREE.Vector3(0, 0, 0),
			new THREE.Vector3(0.5, 0.7, 0),
			new THREE.Vector3(-0.8, -0.4, 0)
		],
		// Custom logic for H2O
		updateLonePairs: updateH2OLonePairs,
		updateAngleDisplay: updateH2OAngle,
		checkBonding: checkH2OBonding
	},
	"CH4": {
		name: "CH₄",
		attractorData: [
			{ name: 'C', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'H1', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H2', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H3', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H4', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }
		],
		lonePairCount: 0,
		initialPositions: [
			new THREE.Vector3(0, 0, 0),
			new THREE.Vector3(0.8, 0.8, 0.8),
			new THREE.Vector3(-0.8, -0.8, 0.8),
			new THREE.Vector3(0.8, -0.8, -0.8),
			new THREE.Vector3(-0.8, 0.8, -0.8)
		],
		// Methane has no lone pairs on central carbon, so no custom lone pair update.
		updateAngleDisplay: updateCH4Angle,
		checkBonding: checkCH4Bonding
	},
	"NH3": {
		name: "NH₃",
		attractorData: [
			{ name: 'N', color: 0x0000ff, mass: 14, amplitude: 2.0, radius: 0.11, coreElectrons: 2, draggable: false },
			{ name: 'H1', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H2', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H3', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }
		],
		lonePairCount: 1,
		initialPositions: [
			new THREE.Vector3(0, 0, 0),
			new THREE.Vector3(0.5, 0.5, 0.5),
			new THREE.Vector3(-0.5, 0.5, -0.5),
			new THREE.Vector3(0, -0.8, 0.5)
		],
		updateLonePairs: updateNH3LonePairs,
		updateAngleDisplay: updateNH3Angle,
		checkBonding: checkNH3Bonding
	},
	"CO2": {
		name: "CO₂",
		attractorData: [
			{ name: 'C', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'O1', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true },
			{ name: 'O2', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true }
		],
		lonePairCount: 0, // No lone pairs on central carbon
		initialPositions: [
			new THREE.Vector3(0, 0, 0),
			new THREE.Vector3(1.0, 0, 0),
			new THREE.Vector3(-1.0, 0, 0)
		],
		updateAngleDisplay: updateCO2Angle,
		checkBonding: checkCO2Bonding
	},
	"C2H4": { // Ethylene - planar molecule with a double bond
		name: "C₂H₄",
		attractorData: [
			{ name: 'C1', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'C2', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'H1', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H2', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H3', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H4', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }
		],
		lonePairCount: 0,
		initialPositions: [
			new THREE.Vector3(-0.6, 0, 0), // C1
			new THREE.Vector3(0.6, 0, 0), // C2
			new THREE.Vector3(-1.2, 0.8, 0), // H1 (attach to C1)
			new THREE.Vector3(-1.2, -0.8, 0), // H2 (attach to C1)
			new THREE.Vector3(1.2, 0.8, 0), // H3 (attach to C2)
			new THREE.Vector3(1.2, -0.8, 0) // H4 (attach to C2)
		],
		updateAngleDisplay: updateC2H4Angle,
		checkBonding: checkC2H4Bonding
	},
	"HCN": { // Linear molecule
		name: "HCN",
		attractorData: [
			{ name: 'H', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'C', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'N', color: 0x0000ff, mass: 14, amplitude: 2.0, radius: 0.11, coreElectrons: 2, draggable: true }
		],
		lonePairCount: 1, // One lone pair on Nitrogen
		initialPositions: [
			new THREE.Vector3(-1.0, 0, 0), // H
			new THREE.Vector3(0, 0, 0), // C
			new THREE.Vector3(1.0, 0, 0) // N
		],
		updateLonePairs: updateHCNLonePairs,
		updateAngleDisplay: updateHCNAngle,
		checkBonding: checkHCNBonding
	},
	"SO2": { // Bent molecule with lone pairs
		name: "SO₂",
		attractorData: [
			{ name: 'S', color: 0xffff00, mass: 32, amplitude: 2.2, radius: 0.13, coreElectrons: 10, draggable: false },
			{ name: 'O1', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true },
			{ name: 'O2', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true }
		],
		lonePairCount: 1, // One lone pair on Sulfur (if treating it as sp2 like)
		initialPositions: [
			new THREE.Vector3(0, 0, 0),
			new THREE.Vector3(1.0, 0.5, 0),
			new THREE.Vector3(-1.0, 0.5, 0)
		],
		updateLonePairs: updateSO2LonePairs,
		updateAngleDisplay: updateSO2Angle,
		checkBonding: checkSO2Bonding
	},
	"H2SO4": { // Sulfuric Acid - A tetrahedral sulfur center with two OH groups and two double-bonded oxygens. Highly asymmetric.
		name: "H₂SO₄",
		attractorData: [
			{ name: 'S', color: 0xffff00, mass: 32, amplitude: 2.2, radius: 0.13, coreElectrons: 10, draggable: false },
			{ name: 'O1', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true }, // Double bond O
			{ name: 'O2', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true }, // Double bond O
			{ name: 'O3', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true }, // Single bond O (to H)
			{ name: 'O4', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true }, // Single bond O (to H)
			{ name: 'H1', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // on O3
			{ name: 'H2', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }  // on O4
		],
		lonePairCount: 0, // Simplified, focus on atom positions
		initialPositions: [
			new THREE.Vector3(0, 0, 0), // S
			new THREE.Vector3(0, 1.2, 0), // O1 (double bond)
			new THREE.Vector3(0, -1.2, 0), // O2 (double bond)
			new THREE.Vector3(1.0, 0, 0.8), // O3 (single bond to H1)
			new THREE.Vector3(-1.0, 0, 0.8), // O4 (single bond to H2)
			new THREE.Vector3(1.6, 0.5, 1.2), // H1 (on O3)
			new THREE.Vector3(-1.6, 0.5, 1.2) // H2 (on O4)
		],
		updateAngleDisplay: updateH2SO4Angle,
		checkBonding: checkH2SO4Bonding
	},
	"CH3COOH": { // Acetic Acid - carboxylic acid group, a methyl group.
		name: "CH₃COOH",
		attractorData: [
			{ name: 'C1', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false }, // Methyl Carbon
			{ name: 'C2', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false }, // Carboxyl Carbon
			{ name: 'O1', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true }, // Double bond O
			{ name: 'O2', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true }, // Hydroxyl O
			{ name: 'H1', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // Methyl H1
			{ name: 'H2', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // Methyl H2
			{ name: 'H3', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // Methyl H3
			{ name: 'H4', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }  // Hydroxyl H
		],
		lonePairCount: 0,
		initialPositions: [
			new THREE.Vector3(-1.0, 0, 0), // C1 (Methyl)
			new THREE.Vector3(0.5, 0, 0), // C2 (Carboxyl)
			new THREE.Vector3(0.5, 1.0, 0), // O1 (double bond)
			new THREE.Vector3(1.5, -0.5, 0), // O2 (hydroxyl)
			new THREE.Vector3(-1.5, 0.8, 0), // H1
			new THREE.Vector3(-1.5, -0.8, 0), // H2
			new THREE.Vector3(-0.5, 0, 0.8), // H3
			new THREE.Vector3(2.0, -0.9, 0) // H4 (on O2)
		],
		updateAngleDisplay: updateCH3COOHAngle,
		checkBonding: checkCH3COOHBonding
	},
	"C6H6": { // Benzene - Planar hexagonal ring, delocalized electrons.
		name: "C₆H₆",
		attractorData: [
			{ name: 'C1', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'C2', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'C3', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'C4', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'C5', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'C6', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'H1', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H2', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H3', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H4', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H5', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true },
			{ name: 'H6', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }
		],
		lonePairCount: 0,
		initialPositions: [
			// Carbon positions (approximate hexagon)
			new THREE.Vector3(0, 1.0, 0),
			new THREE.Vector3(0.866, 0.5, 0),
			new THREE.Vector3(0.866, -0.5, 0),
			new THREE.Vector3(0, -1.0, 0),
			new THREE.Vector3(-0.866, -0.5, 0),
			new THREE.Vector3(-0.866, 0.5, 0),
			// Hydrogen positions (radial outwards)
			new THREE.Vector3(0, 1.8, 0),
			new THREE.Vector3(1.5, 0.9, 0),
			new THREE.Vector3(1.5, -0.9, 0),
			new THREE.Vector3(0, -1.8, 0),
			new THREE.Vector3(-1.5, -0.9, 0),
			new THREE.Vector3(-1.5, 0.9, 0)
		],
		updateAngleDisplay: updateC6H6Angle,
		checkBonding: checkC6H6Bonding
	},
	"C2H5OH": { // Ethanol - an alkyl group and a hydroxyl group
		name: "C₂H₅OH",
		attractorData: [
			{ name: 'C1', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'C2', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'O', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true },
			{ name: 'H1', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // on C1
			{ name: 'H2', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // on C1
			{ name: 'H3', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // on C1
			{ name: 'H4', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // on C2
			{ name: 'H5', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // on C2
			{ name: 'H6', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }  // on O
		],
		lonePairCount: 2, // on Oxygen
		initialPositions: [
			new THREE.Vector3(-0.8, 0, 0), // C1
			new THREE.Vector3(0.5, 0, 0), // C2
			new THREE.Vector3(1.5, 0.5, 0), // O
			new THREE.Vector3(-1.2, 0.8, 0.3), // H1 (C1)
			new THREE.Vector3(-1.2, -0.8, 0.3), // H2 (C1)
			new THREE.Vector3(-0.4, 0, -0.8), // H3 (C1)
			new THREE.Vector3(0.9, 0.8, 0.3), // H4 (C2)
			new THREE.Vector3(0.9, -0.8, 0.3), // H5 (C2)
			new THREE.Vector3(2.0, 0.1, 0) // H6 (O)
		],
		updateLonePairs: updateC2H5OHLonePairs,
		updateAngleDisplay: updateC2H5OHAngle,
		checkBonding: checkC2H5OHBonding
	},
	"NH2CONH2": { // Urea - planar molecule with two amine groups and a carbonyl group.
		name: "NH₂CONH₂",
		attractorData: [
			{ name: 'C', color: 0x808080, mass: 12, amplitude: 2.0, radius: 0.12, coreElectrons: 2, draggable: false },
			{ name: 'O', color: 0xff4136, mass: 16, amplitude: 1.8, radius: 0.1, coreElectrons: 2, draggable: true },
			{ name: 'N1', color: 0x0000ff, mass: 14, amplitude: 2.0, radius: 0.11, coreElectrons: 2, draggable: true },
			{ name: 'N2', color: 0x0000ff, mass: 14, amplitude: 2.0, radius: 0.11, coreElectrons: 2, draggable: true },
			{ name: 'H1', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // on N1
			{ name: 'H2', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // on N1
			{ name: 'H3', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }, // on N2
			{ name: 'H4', color: 0xffffff, mass: 1, amplitude: 1.0, radius: 0.06, coreElectrons: 0, draggable: true }  // on N2
		],
		lonePairCount: 4, // 2 on O, 1 on N1, 1 on N2 (simplified, N lone pairs are active in bonding)
		initialPositions: [
			new THREE.Vector3(0, 0, 0), // C
			new THREE.Vector3(0, 1.0, 0), // O
			new THREE.Vector3(-1.0, -0.5, 0), // N1
			new THREE.Vector3(1.0, -0.5, 0), // N2
			new THREE.Vector3(-1.5, -1.2, 0), // H1 (N1)
			new THREE.Vector3(-0.5, -1.2, 0.5), // H2 (N1)
			new THREE.Vector3(1.5, -1.2, 0), // H3 (N2)
			new THREE.Vector3(0.5, -1.2, 0.5)  // H4 (N2)
		],
		updateLonePairs: updateNH2CONH2LonePairs,
		updateAngleDisplay: updateNH2CONH2Angle,
		checkBonding: checkNH2CONH2Bonding
	},
	"Custom": {
		name: "Custom Molecule",
		attractorData: [], // User defined
		lonePairCount: 0, // User defined
		initialPositions: [], // User defined,
		updateLonePairs: null, // No specific logic for custom
		updateAngleDisplay: null,
		checkBonding: null
	}
};

let currentMoleculeKey = "H2O";
let currentConfig = MOLECULE_CONFIGS[currentMoleculeKey];

function init() {
	scene = new THREE.Scene();
	camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
	camera.position.set(0, 1.5, 4);

	renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.getElementById('container3D').appendChild(renderer.domElement);

	orbitControls = new OrbitControls(camera, renderer.domElement);
	orbitControls.enableDamping = true;

	// Lighting
	scene.add(new THREE.AmbientLight(0xffffff, 0.5));
	const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
	dirLight.position.set(5, 5, 5);
	scene.add(dirLight);
	
	setupUI();
	loadMolecule(currentMoleculeKey);
	animate();
}

function loadMolecule(moleculeKey) {
	currentMoleculeKey = moleculeKey;
	currentConfig = MOLECULE_CONFIGS[currentMoleculeKey];

	// Clear previous molecule
	attractorMeshes.forEach(mesh => scene.remove(mesh));
	attractors = [];
	lonePairs = [];
	attractorMeshes = [];
	if (particleSystem) {
		scene.remove(particleSystem);
		particleSystem.geometry.dispose();
		particleSystem.material.dispose();
		particleSystem = null;
	}

	document.getElementById('moleculeName').textContent = currentConfig.name;

	// Handle Custom Molecule UI
	const customControls = document.getElementById('customMoleculeControls');
	if (moleculeKey === "Custom") {
		customControls.classList.remove('hidden');
		generateCustomAttractorInputs(); // Generate UI for custom atoms
	} else {
		customControls.classList.add('hidden');
	}

	// Attractors (Nuclei) Setup
	currentConfig.attractorData.forEach((data, index) => {
		attractors.push({ 
			...data, 
			vel: new THREE.Vector3(),
			pos: currentConfig.initialPositions[index] ? currentConfig.initialPositions[index].clone() : new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2)
		});
		const mesh = new THREE.Mesh(
			new THREE.SphereGeometry(data.radius, 32, 32),
			new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.5 })
		);
		mesh.position.copy(attractors[index].pos);
		scene.add(mesh);
		attractorMeshes.push(mesh);
	});
	
	// Lone Pair Pseudo-Attractors
	for (let i = 0; i < currentConfig.lonePairCount; i++) {
		lonePairs.push({ pos: new THREE.Vector3(), mass: 0.1, vel: new THREE.Vector3() });
	}

	// Particle System Setup
	reinitParticles(NUM_PARTICLES);

	// Drag Controls
	const draggableObjects = currentConfig.attractorData
							.map((data, idx) => data.draggable ? attractorMeshes[idx] : null)
							.filter(mesh => mesh !== null);
	
	if (dragControls) dragControls.dispose(); // Clean up old controls
	dragControls = new DragControls(draggableObjects, camera, renderer.domElement);
	dragControls.addEventListener('dragstart', () => { userIsDragging = true; orbitControls.enabled = false; });
	dragControls.addEventListener('dragend', () => { userIsDragging = false; orbitControls.enabled = true; });
	dragControls.addEventListener('drag', (event) => {
		 event.object.position.z = 0; // Keep dragged atoms on the XY plane for simplicity
	});
	
	resetSimulation();
}

function reinitParticles(count) {
	if (particleSystem) {
		scene.remove(particleSystem);
		particleSystem.geometry.dispose();
		particleSystem.material.dispose();
	}
	NUM_PARTICLES = count;
	const geom = new THREE.BufferGeometry();
	const positions = new Float32Array(NUM_PARTICLES * 3);
	velocities = new Float32Array(NUM_PARTICLES * 3);
	particleColors = new Float32Array(NUM_PARTICLES * 3);
	
	for (let i = 0; i < NUM_PARTICLES; i++) {
		VALENCE_COLOR.toArray(particleColors, i * 3);
	}

	geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
	geom.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
	
	const material = new THREE.PointsMaterial({ size: 0.005, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.65 });
	particleSystem = new THREE.Points(geom, material);
	scene.add(particleSystem);
	resetSimulation(); // Reset positions after reinitialization
}

// --- Specific Molecule Logic (CO2) ---
function updateCO2Angle() {
	const [c, o1, o2] = attractors;
	if (!c || !o1 || !o2) {
		document.getElementById('angleDisplay').textContent = '';
		return;
	}
	const v1 = new THREE.Vector3().subVectors(o1.pos, c.pos);
	const v2 = new THREE.Vector3().subVectors(o2.pos, c.pos);
	const angleDeg = THREE.MathUtils.radToDeg(v1.angleTo(v2));
	document.getElementById('angleDisplay').textContent = `O-C-O Angle: ${angleDeg.toFixed(1)}°`;
}

function checkCO2Bonding(particlePos, carbonAttractor, oxygenAttractors) {
	const c = carbonAttractor;
	if (!c || oxygenAttractors.length === 0) return false;

	const bondThresholdSq = 0.05;

	for (const o of oxygenAttractors) {
		const vec_C_O = new THREE.Vector3().subVectors(o.pos, c.pos);
		const vec_C_p = new THREE.Vector3().subVectors(particlePos, c.pos);
		const proj = vec_C_p.dot(vec_C_O) / vec_C_O.lengthSq();
		const distSq = vec_C_p.clone().addScaledVector(vec_C_O, -proj).lengthSq();
		if (proj > 0 && proj < 1 && distSq < bondThresholdSq) return true;
	}
	return false;
}

// --- Specific Molecule Logic (C2H4) ---
function updateC2H4Angle() {
    // S'assurer que tous les attracteurs nécessaires existent
    if (attractors.length < 6) { // C1, C2, H1, H2, H3, H4
        document.getElementById('angleDisplay').textContent = '';
        return;
    }
    const c1 = attractors[0];
    const c2 = attractors[1];
    const h1 = attractors[2]; // Un H lié à C1
    // const h3 = attractors[4]; // Un H lié à C2, si on voulait C2-C1-H3

    // Exemple: Angle H1-C1-C2
    const v1 = new THREE.Vector3().subVectors(h1.pos, c1.pos);
    const v2 = new THREE.Vector3().subVectors(c2.pos, c1.pos);
    const angleDeg = THREE.MathUtils.radToDeg(v1.angleTo(v2));
    document.getElementById('angleDisplay').textContent = `H-C-C Angle: ${angleDeg.toFixed(1)}°`;
}

function checkC2H4Bonding(particlePos) {
    // Assurez-vous que les attractors sont disponibles et dans le bon ordre
    if (attractors.length < 6) return false;

    const c1 = attractors[0];
    const c2 = attractors[1];
    const h1 = attractors[2]; // Lié à C1
    const h2 = attractors[3]; // Lié à C1
    const h3 = attractors[4]; // Lié à C2
    const h4 = attractors[5]; // Lié à C2

    const bondThresholdSq = 0.05; // Ajustez si nécessaire

    // Fonction utilitaire pour vérifier une liaison entre deux points
    function isParticleBonded(pPos, startAttractor, endAttractor) {
        const vec_start_end = new THREE.Vector3().subVectors(endAttractor.pos, startAttractor.pos);
        const vec_start_p = new THREE.Vector3().subVectors(pPos, startAttractor.pos);
        const proj = vec_start_p.dot(vec_start_end) / vec_start_end.lengthSq();
        const distSq = vec_start_p.clone().addScaledVector(vec_start_end, -proj).lengthSq();
        return proj > 0 && proj < 1 && distSq < bondThresholdSq;
    }

    // 1. Vérifier la liaison C1-C2 (double liaison)
    if (isParticleBonded(particlePos, c1, c2)) return true;

    // 2. Vérifier les liaisons C1-H
    if (isParticleBonded(particlePos, c1, h1)) return true;
    if (isParticleBonded(particlePos, c1, h2)) return true;

    // 3. Vérifier les liaisons C2-H
    if (isParticleBonded(particlePos, c2, h3)) return true;
    if (isParticleBonded(particlePos, c2, h4)) return true;

    return false;
}

// --- Specific Molecule Logic (HCN) ---
function updateHCNLonePairs() {
	const [h, c, n] = attractors;
	if (!h || !c || !n) return;

	// Lone pair on Nitrogen, pointing away from the Carbon
	const ncVector = new THREE.Vector3().subVectors(c.pos, n.pos).normalize();
	lonePairs[0].pos.copy(n.pos).sub(ncVector.multiplyScalar(0.5)); // Adjust distance
}

function updateHCNAngle() {
	const [h, c, n] = attractors;
	if (!h || !c || !n) {
		document.getElementById('angleDisplay').textContent = '';
		return;
	}
	// For a linear molecule, the angle should be close to 180°
	const v1 = new THREE.Vector3().subVectors(h.pos, c.pos);
	const v2 = new THREE.Vector3().subVectors(n.pos, c.pos);
	const angleDeg = THREE.MathUtils.radToDeg(v1.angleTo(v2));
	document.getElementById('angleDisplay').textContent = `H-C-N Angle: ${angleDeg.toFixed(1)}°`;
}

function checkHCNBonding(particlePos, hydrogenAttractor, carbonAttractor, nitrogenAttractor) {
	const h = hydrogenAttractor;
	const c = carbonAttractor;
	const n = nitrogenAttractor;

	if (!h || !c || !n) return false;

	const bondThresholdSq = 0.05;

	// Check H-C bond
	const vec_H_C = new THREE.Vector3().subVectors(c.pos, h.pos);
	const vec_H_p = new THREE.Vector3().subVectors(particlePos, h.pos);
	const projHC = vec_H_p.dot(vec_H_C) / vec_H_C.lengthSq();
	const distSqHC = vec_H_p.clone().addScaledVector(vec_H_C, -projHC).lengthSq();
	if (projHC > 0 && projHC < 1 && distSqHC < bondThresholdSq) return true;

	// Check C-N bond
	const vec_C_N = new THREE.Vector3().subVectors(n.pos, c.pos);
	const vec_C_p = new THREE.Vector3().subVectors(particlePos, c.pos);
	const projCN = vec_C_p.dot(vec_C_N) / vec_C_N.lengthSq();
	const distSqCN = vec_C_p.clone().addScaledVector(vec_C_N, -projCN).lengthSq();
	if (projCN > 0 && projCN < 1 && distSqCN < bondThresholdSq) return true;

	return false;
}

// --- Specific Molecule Logic (SO2) ---
function updateSO2LonePairs() {
	const [s, o1, o2] = attractors;
	if (!s || !o1 || !o2) return;

	const so1 = new THREE.Vector3().subVectors(o1.pos, s.pos).normalize();
	const so2 = new THREE.Vector3().subVectors(o2.pos, s.pos).normalize();
	const bisector = new THREE.Vector3().addVectors(so1, so2).normalize();

	// Lone pair generally repels from the bonds, typically in the opposite direction of the bisector
	lonePairs[0].pos.copy(s.pos).sub(bisector.multiplyScalar(0.7)); // Adjust distance
}

function updateSO2Angle() {
	const [s, o1, o2] = attractors;
	if (!s || !o1 || !o2) {
		document.getElementById('angleDisplay').textContent = '';
		return;
	}
	const v1 = new THREE.Vector3().subVectors(o1.pos, s.pos);
	const v2 = new THREE.Vector3().subVectors(o2.pos, s.pos);
	const angleDeg = THREE.MathUtils.radToDeg(v1.angleTo(v2));
	document.getElementById('angleDisplay').textContent = `O-S-O Angle: ${angleDeg.toFixed(1)}°`;
}

function checkSO2Bonding(particlePos, sulfurAttractor, oxygenAttractors) {
	const s = sulfurAttractor;
	if (!s || oxygenAttractors.length === 0) return false;

	const bondThresholdSq = 0.05;

	for (const o of oxygenAttractors) {
		const vec_S_O = new THREE.Vector3().subVectors(o.pos, s.pos);
		const vec_S_p = new THREE.Vector3().subVectors(particlePos, s.pos);
		const proj = vec_S_p.dot(vec_S_O) / vec_S_O.lengthSq();
		const distSq = vec_S_p.clone().addScaledVector(vec_S_O, -proj).lengthSq();
		if (proj > 0 && proj < 1 && distSq < bondThresholdSq) return true;
	}
	return false;
}

// --- Specific Molecule Logic (H2SO4) ---
function updateH2SO4Angle() {
    if (attractors.length < 7) { // S, O1, O2, O3, O4, H1, H2
        document.getElementById('angleDisplay').textContent = '';
        return;
    }
    const s = attractors[0];
    const o1 = attractors[1]; // Double bond O
    const o3 = attractors[3]; // Single bond O
    const h1 = attractors[5]; // H on O3

    // Angle O1-S-O3
    const v1 = new THREE.Vector3().subVectors(o1.pos, s.pos);
    const v2 = new THREE.Vector3().subVectors(o3.pos, s.pos);
    const angleOSO = THREE.MathUtils.radToDeg(v1.angleTo(v2));

    // Angle S-O3-H1
    const v3 = new THREE.Vector3().subVectors(s.pos, o3.pos);
    const v4 = new THREE.Vector3().subVectors(h1.pos, o3.pos);
    const angleSOH = THREE.MathUtils.radToDeg(v3.angleTo(v4));

    document.getElementById('angleDisplay').textContent =
        `O=S-O Angle: ${angleOSO.toFixed(1)}° | S-O-H Angle: ${angleSOH.toFixed(1)}°`;
}

function checkH2SO4Bonding(particlePos) {
    if (attractors.length < 7) return false;

    const s = attractors[0];
    const o1 = attractors[1];
    const o2 = attractors[2];
    const o3 = attractors[3];
    const o4 = attractors[4];
    const h1 = attractors[5];
    const h2 = attractors[6];

    const bondThresholdSq = 0.05;

    function isParticleBonded(pPos, startAttractor, endAttractor) {
        const vec_start_end = new THREE.Vector3().subVectors(endAttractor.pos, startAttractor.pos);
        const vec_start_p = new THREE.Vector3().subVectors(pPos, startAttractor.pos);
        const proj = vec_start_p.dot(vec_start_end) / vec_start_end.lengthSq();
        const distSq = vec_start_p.clone().addScaledVector(vec_start_end, -proj).lengthSq();
        return proj > 0 && proj < 1 && distSq < bondThresholdSq;
    }

    // S-O bonds
    if (isParticleBonded(particlePos, s, o1)) return true; // Double bond
    if (isParticleBonded(particlePos, s, o2)) return true; // Double bond
    if (isParticleBonded(particlePos, s, o3)) return true; // Single bond
    if (isParticleBonded(particlePos, s, o4)) return true; // Single bond

    // O-H bonds
    if (isParticleBonded(particlePos, o3, h1)) return true;
    if (isParticleBonded(particlePos, o4, h2)) return true;

    return false;
}

// --- Specific Molecule Logic (CH3COOH) ---
function updateCH3COOHAngle() {
    if (attractors.length < 8) { // C1, C2, O1, O2, H1, H2, H3, H4
        document.getElementById('angleDisplay').textContent = '';
        return;
    }
    const c1 = attractors[0];
    const c2 = attractors[1];
    const o1 = attractors[2]; // Double bond O
    const o2 = attractors[3]; // Hydroxyl O
    const h1 = attractors[4]; // H on C1
    const h4 = attractors[7]; // H on O2

    // Angle H1-C1-C2 (Methyl group)
    const v1 = new THREE.Vector3().subVectors(h1.pos, c1.pos);
    const v2 = new THREE.Vector3().subVectors(c2.pos, c1.pos);
    const angleHCC = THREE.MathUtils.radToDeg(v1.angleTo(v2));

    // Angle O1=C2-O2 (Carboxyl group)
    const v3 = new THREE.Vector3().subVectors(o1.pos, c2.pos);
    const v4 = new THREE.Vector3().subVectors(o2.pos, c2.pos);
    const angleOCO = THREE.MathUtils.radToDeg(v3.angleTo(v4));

    document.getElementById('angleDisplay').textContent =
        `H-C-C Angle: ${angleHCC.toFixed(1)}° | O=C-O Angle: ${angleOCO.toFixed(1)}°`;
}

function checkCH3COOHBonding(particlePos) {
    if (attractors.length < 8) return false;

    const c1 = attractors[0];
    const c2 = attractors[1];
    const o1 = attractors[2];
    const o2 = attractors[3];
    const h1 = attractors[4];
    const h2 = attractors[5];
    const h3 = attractors[6];
    const h4 = attractors[7];

    const bondThresholdSq = 0.05;

    function isParticleBonded(pPos, startAttractor, endAttractor) {
        const vec_start_end = new THREE.Vector3().subVectors(endAttractor.pos, startAttractor.pos);
        const vec_start_p = new THREE.Vector3().subVectors(pPos, startAttractor.pos);
        const proj = vec_start_p.dot(vec_start_end) / vec_start_end.lengthSq();
        const distSq = vec_start_p.clone().addScaledVector(vec_start_end, -proj).lengthSq();
        return proj > 0 && proj < 1 && distSq < bondThresholdSq;
    }

    // C1-C2 bond
    if (isParticleBonded(particlePos, c1, c2)) return true;

    // C1-H bonds
    if (isParticleBonded(particlePos, c1, h1)) return true;
    if (isParticleBonded(particlePos, c1, h2)) return true;
    if (isParticleBonded(particlePos, c1, h3)) return true;

    // C2=O1 bond
    if (isParticleBonded(particlePos, c2, o1)) return true;

    // C2-O2 bond
    if (isParticleBonded(particlePos, c2, o2)) return true;

    // O2-H4 bond
    if (isParticleBonded(particlePos, o2, h4)) return true;

    return false;
}

// --- Specific Molecule Logic (C6H6) ---
function updateC6H6Angle() {
    if (attractors.length < 12) { // C1-C6, H1-H6
        document.getElementById('angleDisplay').textContent = '';
        return;
    }
    const c1 = attractors[0];
    const c2 = attractors[1];
    const c3 = attractors[2];
    const h1 = attractors[6];

    // Angle C6-C1-C2 (inside the ring)
    const v1 = new THREE.Vector3().subVectors(attractors[5].pos, c1.pos); // C6
    const v2 = new THREE.Vector3().subVectors(c2.pos, c1.pos);
    const angleCCC = THREE.MathUtils.radToDeg(v1.angleTo(v2));

    // Angle H1-C1-C2 (outside the ring)
    const v3 = new THREE.Vector3().subVectors(h1.pos, c1.pos);
    const v4 = new THREE.Vector3().subVectors(c2.pos, c1.pos);
    const angleHCC = THREE.MathUtils.radToDeg(v3.angleTo(v4));

    document.getElementById('angleDisplay').textContent =
        `C-C-C Angle: ${angleCCC.toFixed(1)}° | H-C-C Angle: ${angleHCC.toFixed(1)}°`;
}

function checkC6H6Bonding(particlePos) {
    if (attractors.length < 12) return false;

    const bondThresholdSq = 0.05;

    function isParticleBonded(pPos, startAttractor, endAttractor) {
        const vec_start_end = new THREE.Vector3().subVectors(endAttractor.pos, startAttractor.pos);
        const vec_start_p = new THREE.Vector3().subVectors(pPos, startAttractor.pos);
        const proj = vec_start_p.dot(vec_start_end) / vec_start_end.lengthSq();
        const distSq = vec_start_p.clone().addScaledVector(vec_start_end, -proj).lengthSq();
        return proj > 0 && proj < 1 && distSq < bondThresholdSq;
    }

    // C-C bonds in the ring
    for (let i = 0; i < 6; i++) {
        const c1 = attractors[i];
        const c2 = attractors[(i + 1) % 6]; // Wrap around for C6-C1
        if (isParticleBonded(particlePos, c1, c2)) return true;
    }

    // C-H bonds
    for (let i = 0; i < 6; i++) {
        const carbon = attractors[i];
        const hydrogen = attractors[i + 6];
        if (isParticleBonded(particlePos, carbon, hydrogen)) return true;
    }

    return false;
}

// --- Specific Molecule Logic (C2H5OH) ---
function updateC2H5OHLonePairs() {
	const [c1, c2, o, h1, h2, h3, h4, h5, h6] = attractors;
	if (!c1 || !c2 || !o) return;

	// Lone pairs on Oxygen. They repel from the C-O bond and O-H bond.
	const coVector = new THREE.Vector3().subVectors(c2.pos, o.pos).normalize();
	const ohVector = new THREE.Vector3().subVectors(h6.pos, o.pos).normalize();

	// Approximate position by taking vectors roughly perpendicular to the bonds.
	// This is a simplification; a more accurate model would consider VSEPR theory.
	const normal = new THREE.Vector3().crossVectors(coVector, ohVector).normalize();
	const bisector = new THREE.Vector3().addVectors(coVector, ohVector).normalize();

	// Lone pair 1 (away from C-O and O-H)
	lonePairs[0].pos.copy(o.pos).add(normal.multiplyScalar(0.5));
	// Lone pair 2 (opposite direction)
	lonePairs[1].pos.copy(o.pos).sub(normal.multiplyScalar(0.5));
}

function updateC2H5OHAngle() {
    if (attractors.length < 9) { // C1, C2, O, H1-H6
        document.getElementById('angleDisplay').textContent = '';
        return;
    }
    const c1 = attractors[0];
    const c2 = attractors[1];
    const o = attractors[2];
    const h6 = attractors[8]; // H on O

    // Angle C1-C2-O
    const v1 = new THREE.Vector3().subVectors(c1.pos, c2.pos);
    const v2 = new THREE.Vector3().subVectors(o.pos, c2.pos);
    const angleCCO = THREE.MathUtils.radToDeg(v1.angleTo(v2));

    // Angle C2-O-H
    const v3 = new THREE.Vector3().subVectors(c2.pos, o.pos);
    const v4 = new THREE.Vector3().subVectors(h6.pos, o.pos);
    const angleCOH = THREE.MathUtils.radToDeg(v3.angleTo(v4));

    document.getElementById('angleDisplay').textContent =
        `C-C-O Angle: ${angleCCO.toFixed(1)}° | C-O-H Angle: ${angleCOH.toFixed(1)}°`;
}

function checkC2H5OHBonding(particlePos) {
    if (attractors.length < 9) return false;

    const c1 = attractors[0];
    const c2 = attractors[1];
    const o = attractors[2];
    const h1 = attractors[3];
    const h2 = attractors[4];
    const h3 = attractors[5];
    const h4 = attractors[6];
    const h5 = attractors[7];
    const h6 = attractors[8];

    const bondThresholdSq = 0.05;

    function isParticleBonded(pPos, startAttractor, endAttractor) {
        const vec_start_end = new THREE.Vector3().subVectors(endAttractor.pos, startAttractor.pos);
        const vec_start_p = new THREE.Vector3().subVectors(pPos, startAttractor.pos);
        const proj = vec_start_p.dot(vec_start_end) / vec_start_end.lengthSq();
        const distSq = vec_start_p.clone().addScaledVector(vec_start_end, -proj).lengthSq();
        return proj > 0 && proj < 1 && distSq < bondThresholdSq;
    }

    // C1-C2 bond
    if (isParticleBonded(particlePos, c1, c2)) return true;

    // C2-O bond
    if (isParticleBonded(particlePos, c2, o)) return true;

    // O-H bond
    if (isParticleBonded(particlePos, o, h6)) return true;

    // C1-H bonds
    if (isParticleBonded(particlePos, c1, h1)) return true;
    if (isParticleBonded(particlePos, c1, h2)) return true;
    if (isParticleBonded(particlePos, c1, h3)) return true;

    // C2-H bonds
    if (isParticleBonded(particlePos, c2, h4)) return true;
    if (isParticleBonded(particlePos, c2, h5)) return true;

    return false;
}

// --- Specific Molecule Logic (NH2CONH2) ---
function updateNH2CONH2LonePairs() {
	const [c, o, n1, n2, h1, h2, h3, h4] = attractors;
	if (!c || !o || !n1 || !n2) return;

	// Lone pairs on N1, N2, and O.
	// This is a simplification; the exact positions of lone pairs would depend on hybridization.

	// For Oxygen (double bonded to Carbon), two lone pairs
	const coVector = new THREE.Vector3().subVectors(c.pos, o.pos).normalize();
	// We can place them roughly perpendicular to the C-O bond.
	lonePairs[0].pos.copy(o.pos).add(new THREE.Vector3().crossVectors(coVector, new THREE.Vector3(0, 0, 1)).normalize().multiplyScalar(0.5));
	lonePairs[1].pos.copy(o.pos).sub(new THREE.Vector3().crossVectors(coVector, new THREE.Vector3(0, 0, 1)).normalize().multiplyScalar(0.5));


	// For N1 (amine), one lone pair. Points away from C-N and N-H bonds.
	const cn1Vector = new THREE.Vector3().subVectors(c.pos, n1.pos).normalize();
	const nh1Vector = new THREE.Vector3().subVectors(h1.pos, n1.pos).normalize();
	const nh2Vector = new THREE.Vector3().subVectors(h2.pos, n1.pos).normalize();
	// Using average of bond directions to find opposite direction for lone pair
	const n1RepulsionVector = new THREE.Vector3().addVectors(cn1Vector, nh1Vector).add(nh2Vector).normalize();
	lonePairs[2].pos.copy(n1.pos).sub(n1RepulsionVector.multiplyScalar(0.5));

	// For N2 (amine), one lone pair.
	const cn2Vector = new THREE.Vector3().subVectors(c.pos, n2.pos).normalize();
	const nh3Vector = new THREE.Vector3().subVectors(h3.pos, n2.pos).normalize();
	const nh4Vector = new THREE.Vector3().subVectors(h4.pos, n2.pos).normalize();
	// Using average of bond directions to find opposite direction for lone pair
	const n2RepulsionVector = new THREE.Vector3().addVectors(cn2Vector, nh3Vector).add(nh4Vector).normalize();
	lonePairs[3].pos.copy(n2.pos).sub(n2RepulsionVector.multiplyScalar(0.5));
}

function updateNH2CONH2Angle() {
    if (attractors.length < 8) { // C, O, N1, N2, H1-H4
        document.getElementById('angleDisplay').textContent = '';
        return;
    }
    const c = attractors[0];
    const o = attractors[1];
    const n1 = attractors[2];
    const n2 = attractors[3];
    const h1 = attractors[4]; // H on N1

    // Angle N1-C-N2 (around the central carbon)
    const v1 = new THREE.Vector3().subVectors(n1.pos, c.pos);
    const v2 = new THREE.Vector3().subVectors(n2.pos, c.pos);
    const angleNCN = THREE.MathUtils.radToDeg(v1.angleTo(v2));

    // Angle O=C-N1
    const v3 = new THREE.Vector3().subVectors(o.pos, c.pos);
    const v4 = new THREE.Vector3().subVectors(n1.pos, c.pos);
    const angleOCN = THREE.MathUtils.radToDeg(v3.angleTo(v4));

    // Angle C-N1-H1
    const v5 = new THREE.Vector3().subVectors(c.pos, n1.pos);
    const v6 = new THREE.Vector3().subVectors(h1.pos, n1.pos);
    const angleCNH = THREE.MathUtils.radToDeg(v5.angleTo(v6));

    document.getElementById('angleDisplay').textContent =
        `N-C-N Angle: ${angleNCN.toFixed(1)}° | O=C-N Angle: ${angleOCN.toFixed(1)}° | C-N-H Angle: ${angleCNH.toFixed(1)}°`;
}

function checkNH2CONH2Bonding(particlePos) {
    if (attractors.length < 8) return false;

    const c = attractors[0];
    const o = attractors[1];
    const n1 = attractors[2];
    const n2 = attractors[3];
    const h1 = attractors[4];
    const h2 = attractors[5];
    const h3 = attractors[6];
    const h4 = attractors[7];

    const bondThresholdSq = 0.05;

    function isParticleBonded(pPos, startAttractor, endAttractor) {
        const vec_start_end = new THREE.Vector3().subVectors(endAttractor.pos, startAttractor.pos);
        const vec_start_p = new THREE.Vector3().subVectors(pPos, startAttractor.pos);
        const proj = vec_start_p.dot(vec_start_end) / vec_start_end.lengthSq();
        const distSq = vec_start_p.clone().addScaledVector(vec_start_end, -proj).lengthSq();
        return proj > 0 && proj < 1 && distSq < bondThresholdSq;
    }

    // C=O bond
    if (isParticleBonded(particlePos, c, o)) return true;

    // C-N1 bond
    if (isParticleBonded(particlePos, c, n1)) return true;

    // C-N2 bond
    if (isParticleBonded(particlePos, c, n2)) return true;

    // N1-H bonds
    if (isParticleBonded(particlePos, n1, h1)) return true;
    if (isParticleBonded(particlePos, n1, h2)) return true;

    // N2-H bonds
    if (isParticleBonded(particlePos, n2, h3)) return true;
    if (isParticleBonded(particlePos, n2, h4)) return true;

    return false;
}

// --- Specific Molecule Logic (H2O) ---
function updateH2OLonePairs() {
	const [o, h1, h2] = attractors; // O, H1, H2 are the first three attractors
	if (!o || !h1 || !h2) return;

	// Calculate bond vectors and their bisector
	const oh1 = new THREE.Vector3().subVectors(h1.pos, o.pos).normalize();
	const oh2 = new THREE.Vector3().subVectors(h2.pos, o.pos).normalize();
	const bisector = new THREE.Vector3().addVectors(oh1, oh2).normalize();
	
	// Calculate a vector perpendicular to the plane formed by O, H1, H2
	const cross = new THREE.Vector3().crossVectors(oh1, oh2).normalize();
	
	// Position lone pairs tetrahedrally around Oxygen, repelling from existing bonds
	const lonePairDistance = 0.6; // Distance from Oxygen
	const lonePairOffset = 0.7; // How far they are from the bisector in the perpendicular direction
	
	// Lone pairs are placed relative to the Oxygen, away from the H-O-H plane and bisector
	lonePairs[0].pos.copy(o.pos).sub(bisector.clone().multiplyScalar(lonePairDistance)).add(cross.clone().multiplyScalar(lonePairOffset));
	lonePairs[1].pos.copy(o.pos).sub(bisector.clone().multiplyScalar(lonePairDistance)).sub(cross.clone().multiplyScalar(lonePairOffset));
}

function updateH2OAngle() {
	const [o, h1, h2] = attractors;
	if (!o || !h1 || !h2) {
		document.getElementById('angleDisplay').textContent = '';
		return;
	}
	const v1 = new THREE.Vector3().subVectors(h1.pos, o.pos);
	const v2 = new THREE.Vector3().subVectors(h2.pos, o.pos);
	const angleDeg = THREE.MathUtils.radToDeg(v1.angleTo(v2));
	document.getElementById('angleDisplay').textContent = `H-O-H Angle: ${angleDeg.toFixed(1)}°`;
}

function checkH2OBonding(particlePos, oxygenAttractor, hydrogenAttractors) {
	const [h1, h2] = hydrogenAttractors; 
	const o = oxygenAttractor;

	if (!o || !h1 || !h2) return false;

	const bondThresholdSq = 0.05;

	const vec_O_H1 = new THREE.Vector3().subVectors(h1.pos, o.pos);
	const vec_O_p = new THREE.Vector3().subVectors(particlePos, o.pos);
	const proj1 = vec_O_p.dot(vec_O_H1) / vec_O_H1.lengthSq();
	const distSq1 = vec_O_p.clone().addScaledVector(vec_O_H1, -proj1).lengthSq();
	if (proj1 > 0 && proj1 < 1 && distSq1 < bondThresholdSq) return true;

	const vec_O_H2 = new THREE.Vector3().subVectors(h2.pos, o.pos);
	const proj2 = vec_O_p.dot(vec_O_H2) / vec_O_H2.lengthSq();
	const distSq2 = vec_O_p.clone().addScaledVector(vec_O_H2, -proj2).lengthSq();

	if (proj2 > 0 && proj2 < 1 && distSq2 < bondThresholdSq) return true;

	return false;
}

// --- Specific Molecule Logic (CH4) ---
function updateCH4Angle() {
	const [c, h1, h2] = attractors; // Central Carbon and two Hydrogens
	if (!c || !h1 || !h2) {
		document.getElementById('angleDisplay').textContent = '';
		return;
	}
	const v1 = new THREE.Vector3().subVectors(h1.pos, c.pos);
	const v2 = new THREE.Vector3().subVectors(h2.pos, c.pos);
	const angleDeg = THREE.MathUtils.radToDeg(v1.angleTo(v2));
	document.getElementById('angleDisplay').textContent = `H-C-H Angle: ${angleDeg.toFixed(1)}°`;
}

function checkCH4Bonding(particlePos, carbonAttractor, hydrogenAttractors) {
	const c = carbonAttractor;
	if (!c || hydrogenAttractors.length === 0) return false;

	const bondThresholdSq = 0.05;

	for (const h of hydrogenAttractors) {
		const vec_C_H = new THREE.Vector3().subVectors(h.pos, c.pos);
		const vec_C_p = new THREE.Vector3().subVectors(particlePos, c.pos);
		const proj = vec_C_p.dot(vec_C_H) / vec_C_H.lengthSq();
		const distSq = vec_C_p.clone().addScaledVector(vec_C_H, -proj).lengthSq();
		if (proj > 0 && proj < 1 && distSq < bondThresholdSq) return true;
	}
	return false;
}

// --- Specific Molecule Logic (NH3) ---
function updateNH3LonePairs() {
	const [n, h1, h2, h3] = attractors;
	if (!n || !h1 || !h2 || !h3) return;

	// Calculate the centroid of the three hydrogen atoms
	const hCentroid = new THREE.Vector3().addVectors(h1.pos, h2.pos).add(h3.pos).divideScalar(3);
	// The lone pair is positioned along the axis from the centroid of H atoms through the N atom,
	// extending away from the H atoms.
	const lonePairDirection = new THREE.Vector3().subVectors(n.pos, hCentroid).normalize();
	lonePairs[0].pos.copy(n.pos).add(lonePairDirection.multiplyScalar(0.7)); // Adjust distance as needed
}

function updateNH3Angle() {
	const [n, h1, h2] = attractors; // Take two Hydrogens for the angle
	if (!n || !h1 || !h2) {
		document.getElementById('angleDisplay').textContent = '';
		return;
	}
	const v1 = new THREE.Vector3().subVectors(h1.pos, n.pos);
	const v2 = new THREE.Vector3().subVectors(h2.pos, n.pos);
	const angleDeg = THREE.MathUtils.radToDeg(v1.angleTo(v2));
	document.getElementById('angleDisplay').textContent = `H-N-H Angle: ${angleDeg.toFixed(1)}°`;
}

function checkNH3Bonding(particlePos, nitrogenAttractor, hydrogenAttractors) {
	const n = nitrogenAttractor;
	if (!n || hydrogenAttractors.length === 0) return false;

	const bondThresholdSq = 0.05;

	for (const h of hydrogenAttractors) {
		const vec_N_H = new THREE.Vector3().subVectors(h.pos, n.pos);
		const vec_N_p = new THREE.Vector3().subVectors(particlePos, n.pos);
		const proj = vec_N_p.dot(vec_N_H) / vec_N_H.lengthSq();
		const distSq = vec_N_p.clone().addScaledVector(vec_N_H, -proj).lengthSq();
		if (proj > 0 && proj < 1 && distSq < bondThresholdSq) return true;
	}
	return false;
}

/*
 * Simulates a simplified quantum wave function.
 * The amplitude decreases with distance and oscillates.
*/
function waveFunction(pos, attractor) {
	const r = pos.distanceTo(attractor.pos);
	if (r < 0.001) return attractor.amplitude; // Avoid division by zero at the nucleus
	return attractor.amplitude * Math.cos(QUANTUM_CONSTANT_K * r) / r;
}

// --- Custom Molecule Logic ---
function generateCustomAttractorInputs() {
	const container = document.getElementById('customAttractorInputs');
	container.innerHTML = ''; // Clear existing inputs

	currentConfig.attractorData.forEach((attractor, index) => {
		const div = document.createElement('div');
		div.className = 'grid grid-cols-5 gap-2 items-end p-2 border border-gray-700 rounded-md bg-gray-800';
		div.innerHTML = `
			<div class="input-group col-span-1">
				<label>Name</label>
				<input type="text" data-index="${index}" data-prop="name" value="${attractor.name}" class="w-full bg-gray-700 border-gray-600 text-white rounded-md p-1 text-xs">
			</div>
			<div class="input-group col-span-1">
				<label>Color</label>
				<input type="color" data-index="${index}" data-prop="color" value="#${new THREE.Color(attractor.color).getHexString()}" class="w-full h-7 bg-gray-700">
			</div>
			<div class="input-group col-span-1">
				<label>Mass</label>
				<input type="number" data-index="${index}" data-prop="mass" value="${attractor.mass}" min="1" step="1" class="w-full bg-gray-700 border-gray-600 text-white rounded-md p-1 text-xs">
			</div>
			<div class="input-group col-span-1">
				<label>Radius</label>
				<input type="number" data-index="${index}" data-prop="radius" value="${attractor.radius}" min="0.01" max="0.5" step="0.01" class="w-full bg-gray-700 border-gray-600 text-white rounded-md p-1 text-xs">
			</div>
			<div class="input-group col-span-1 flex items-center justify-center">
				<label class="flex items-center">
					<span class="text-xs mr-1">Draggable</span>
					<input type="checkbox" data-index="${index}" data-prop="draggable" ${attractor.draggable ? 'checked' : ''} class="w-auto h-4">
				</label>
			</div>
			<div class="input-group col-span-5 flex justify-end">
				<button class="remove-attractor-btn bg-red-600 hover:bg-red-500 text-white text-xs px-3 py-1 rounded transition duration-300" data-index="${index}">Remove</button>
			</div>
		`;
		container.appendChild(div);
	});

	container.querySelectorAll('input').forEach(input => {
		input.addEventListener('change', (e) => {
			const index = parseInt(e.target.dataset.index);
			const prop = e.target.dataset.prop;
			let value = e.target.value;

			if (prop === 'color') {
				value = parseInt(value.replace('#', '0x'), 16);
			} else if (prop === 'mass' || prop === 'radius') {
				value = parseFloat(value);
			} else if (prop === 'draggable') {
				value = e.target.checked;
			}
			currentConfig.attractorData[index][prop] = value;
			loadMolecule("Custom"); // Reload to apply changes
		});
	});

	container.querySelectorAll('.remove-attractor-btn').forEach(btn => {
		btn.addEventListener('click', (e) => {
			const index = parseInt(e.target.dataset.index);
			currentConfig.attractorData.splice(index, 1);
			currentConfig.initialPositions.splice(index, 1); // Also remove initial position
			loadMolecule("Custom");
		});
	});

	document.getElementById('addAttractorBtn').onclick = () => {
		currentConfig.attractorData.push({ 
			name: `Atom${currentConfig.attractorData.length + 1}`, 
			color: 0xcccccc, mass: 1, amplitude: 1.0, radius: 0.08, coreElectrons: 0, draggable: true 
		});
		currentConfig.initialPositions.push(new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2));
		loadMolecule("Custom");
	};
	document.getElementById('customLonePairCount').onchange = (e) => {
		currentConfig.lonePairCount = parseInt(e.target.value);
		loadMolecule("Custom");
	};
}

/**
 * Updates the positions and velocities of the attractors (nuclei and lone pairs)
 * based on a simplified repulsive force model.
 */
function updateAttractorPhysics() {
	if (!simulationActive || userIsDragging) return;

	// Update lone pair positions based on current molecule geometry
	if (currentConfig.updateLonePairs) {
		currentConfig.updateLonePairs();
	}

	const allAtoms = [...attractors, ...lonePairs];

	// Calculate repulsive forces between all attractors (nuclei and lone pairs)
	for (let i = 0; i < allAtoms.length; i++) {
		// Nuclei have a 'mass' property, lone pairs have a fixed pseudo-mass (0.1)
		const a1 = allAtoms[i];
		const mass1 = a1.mass || 0.1; 

		for (let j = i + 1; j < allAtoms.length; j++) {
			const a2 = allAtoms[j];
			const mass2 = a2.mass || 0.1;

			const direction = new THREE.Vector3().subVectors(a1.pos, a2.pos);
			const distanceSq = direction.lengthSq();

			if (distanceSq > 1e-4) { // Prevent division by zero if atoms overlap
				let forceMagnitude = REPULSION_FORCE_MAGNITUDE / distanceSq;

				// Apply stronger repulsion for lone pair interactions
				const isLonePairInteraction = (i >= attractors.length || j >= attractors.length);
				if (isLonePairInteraction) {
					forceMagnitude *= LONE_PAIR_REPULSION_MULTIPLIER;
				}

				const force = direction.normalize().multiplyScalar(forceMagnitude);
				
				// Apply force, scaled by mass
				a1.vel.add(force.clone().divideScalar(mass1));
				a2.vel.sub(force.clone().divideScalar(mass2));
			}
		}
	}

	// Update positions based on velocities and apply damping
	attractors.forEach(a => { 
		a.vel.multiplyScalar(ATTRACTOR_DAMPING); 
		a.pos.add(a.vel); 
	});
}

/**
 * Updates the positions and velocities of the electron cloud particles.
 * Particles are attracted to regions of high wave function probability (nuclei).
 * Colors particles based on core/valence/bonding status.
 */
function updateParticlePhysics() {
	if (!simulationActive) return;
	const posAttr = particleSystem.geometry.getAttribute('position');
	const colAttr = particleSystem.geometry.getAttribute('color');
	const p = new THREE.Vector3();
	
	// Assume the first attractor is the central atom for core electrons
	const centralAttractor = attractors[0];
	const coreAttractorPresent = centralAttractor && centralAttractor.coreElectrons > 0;

	const hydrogenAttractors = attractors.slice(1); // Assuming H atoms are subsequent attractors

	for (let i = 0; i < NUM_PARTICLES; i++) {
		p.fromBufferAttribute(posAttr, i);
		let totalWave = 0;
		const gradient = new THREE.Vector3();
		const epsilon = 0.01; // Small displacement for gradient calculation
		
		// Sum wave functions from all nuclei to find areas of high probability
		attractors.forEach(a => {
			const baseWave = waveFunction(p.clone(), a);
			totalWave += baseWave;

			// Approximate gradient of the wave function
			gradient.x += (waveFunction(p.clone().add({x:epsilon, y:0, z:0}), a) - baseWave) / epsilon;
			gradient.y += (waveFunction(p.clone().add({x:0, y:epsilon, z:0}), a) - baseWave) / epsilon;
			gradient.z += (waveFunction(p.clone().add({x:0, y:0, z:epsilon}), a) - baseWave) / epsilon;
		});
		
		// Force derived from the gradient of the wave function,
		// pushes particles towards regions of higher probability (maxima of totalWave).
		let forceMultiplier = -0.003 * Math.tanh(totalWave); // Tanh smooths the force
		
		// --- Particle Coloring Logic ---
		let currentColor = VALENCE_COLOR; // Default to valence color

		// Core electrons (particles near the central nucleus, if configured)
		if (coreAttractorPresent && i < CORE_ELECTRON_COUNT && p.distanceToSquared(centralAttractor.pos) < 0.5) { 
			currentColor = CORE_COLOR;
			// Stronger attraction for core electrons to keep them close to the nucleus
			forceMultiplier *= (1 + 20 / (p.distanceToSquared(centralAttractor.pos) + 0.1));
		} else {
			// Valence electron logic (bonding)
			if (showBonds && currentConfig.checkBonding && currentConfig.checkBonding(p, centralAttractor, hydrogenAttractors)) {
				 currentColor = BOND_COLOR;
			}
		}
		currentColor.toArray(particleColors, i * 3);
		
		const ix = i * 3;
		// Apply force to velocity
		velocities[ix] += gradient.x * forceMultiplier;
		velocities[ix+1] += gradient.y * forceMultiplier;
		velocities[ix+2] += gradient.z * forceMultiplier;

		// Apply damping to particle velocities
		velocities[ix] *= PARTICLE_DAMPING;
		velocities[ix+1] *= PARTICLE_DAMPING;
		velocities[ix+2] *= PARTICLE_DAMPING;

		// Update particle position
		posAttr.setXYZ(i, p.x + velocities[ix], p.y + velocities[ix+1], p.z + velocities[ix+2]);
	}
	posAttr.needsUpdate = true;
	colAttr.needsUpdate = true;
}

function animate() {
	requestAnimationFrame(animate);

	// Sync attractor data with mesh positions, especially after user drag
	if (userIsDragging) {
		currentConfig.attractorData.forEach((data, idx) => {
			if (data.draggable) {
				attractors[idx].pos.copy(attractorMeshes[idx].position);
				attractors[idx].vel.set(0,0,0); // Stop movement while dragging
			}
		});
	}

	updateAttractorPhysics();
	// Update the visual mesh positions to match the simulation's attractor positions
	attractors.forEach((a, i) => attractorMeshes[i].position.copy(a.pos));
	updateParticlePhysics();
	
	// Check if the system has settled (velocities are very low)
	const totalVelSq = attractors.reduce((sum, a) => sum + a.vel.lengthSq(), 0);
	if (simulationActive && totalVelSq < 1e-5 && !userIsDragging) {
		if (currentConfig.updateAngleDisplay) {
			currentConfig.updateAngleDisplay();
		} else {
			document.getElementById('angleDisplay').textContent = 'System stable.';
		}
	} else if (simulationActive) {
		document.getElementById('angleDisplay').textContent = 'System settling...';
	}

	orbitControls.update();
	renderer.render(scene, camera);
}

function setupUI() {
	const draggablePanelContainer = document.getElementById('draggable-panel-container');
	const dragHandle = document.getElementById('drag-handle');
	const uiPanel = document.getElementById('ui-panel'), toggleUiBtn = document.getElementById('toggleUiBtn'), uiIcon = document.getElementById('ui-icon');
	
	// General Controls
	const particleCountSlider = document.getElementById('particleCountSlider');
	const boxSizeSlider = document.getElementById('boxSizeSlider');
	const particleCountLabel = document.getElementById('particleCountLabel');
	const particleDampingSlider = document.getElementById('particleDampingSlider');
	const particleDampingLabel = document.getElementById('particleDampingLabel');
	const attractorDampingSlider = document.getElementById('attractorDampingSlider');
	const attractorDampingLabel = document.getElementById('attractorDampingLabel');
	const quantumConstantSlider = document.getElementById('quantumConstantSlider');
	const quantumConstantLabel = document.getElementById('quantumConstantLabel');
	const repulsionForceSlider = document.getElementById('repulsionForceSlider');
	const repulsionForceLabel = document.getElementById('repulsionForceLabel');
	const lpRepulsionMultiplierSlider = document.getElementById('lpRepulsionMultiplierSlider');
	const lpRepulsionMultiplierLabel = document.getElementById('lpRepulsionMultiplierLabel');
	const coreElectronCountSlider = document.getElementById('coreElectronCountSlider');
	const coreElectronCountLabel = document.getElementById('coreElectronCountLabel');


	// Color Pickers
	const valenceColorPicker = document.getElementById('valenceColorPicker');
	const coreColorPicker = document.getElementById('coreColorPicker');
	const bondColorPicker = document.getElementById('bondColorPicker');

	let isDraggingPanel = false;
	let offset = { x: 0, y: 0 };

	dragHandle.addEventListener('mousedown', (e) => {
		isDraggingPanel = true;
		draggablePanelContainer.classList.add('dragging');
		offset.x = e.clientX - draggablePanelContainer.getBoundingClientRect().left;
		offset.y = e.clientY - draggablePanelContainer.getBoundingClientRect().top;
		draggablePanelContainer.style.transform = 'none'; // Remove center transform for absolute positioning
		draggablePanelContainer.style.left = `${e.clientX - offset.x}px`;
		draggablePanelContainer.style.top = `${e.clientY - offset.y}px`;
		orbitControls.enabled = false;
	});

	document.addEventListener('mousemove', (e) => {
		if (!isDraggingPanel) return;
		draggablePanelContainer.style.left = `${e.clientX - offset.x}px`;
		draggablePanelContainer.style.top = `${e.clientY - offset.y}px`;
	});

	document.addEventListener('mouseup', () => {
		isDraggingPanel = false;
		draggablePanelContainer.classList.remove('dragging');
		orbitControls.enabled = true;
	});

	document.getElementById('formBtn').addEventListener('click', () => { 
		if (!simulationActive) { 
			resetSimulation(); // Reset to initial state
			simulationActive = true; 
		} 
	});
	document.getElementById('resetBtn').addEventListener('click', resetSimulation);
	
	toggleUiBtn.addEventListener('click', () => {
		const isHidden = uiPanel.classList.toggle('hidden');
		uiIcon.innerHTML = isHidden ? `<path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" />` : `<path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />`;
		toggleUiBtn.style.opacity = isHidden ? '0.5' : '1';
	});

	document.getElementById('showNucleiToggle').addEventListener('change', (e) => { 
		attractorMeshes.forEach(mesh => mesh.visible = e.target.checked); 
	});
	document.getElementById('showBondsToggle').addEventListener('change', (e) => { 
		showBonds = e.target.checked; 
	});

	// Sliders for physics parameters
	particleCountSlider.addEventListener('input', (e) => { particleCountLabel.textContent = e.target.value; });
	particleCountSlider.addEventListener('change', (e) => { reinitParticles(parseInt(e.target.value)); });
	
	boxSizeSlider.addEventListener('input', (e) => { 
		LENGHT = parseFloat(e.target.value); 
		boxSizeLabel.textContent = LENGHT.toFixed(1);
		resetSimulation();
	});

	particleDampingSlider.addEventListener('input', (e) => { 
		PARTICLE_DAMPING = parseFloat(e.target.value); 
		particleDampingLabel.textContent = PARTICLE_DAMPING.toFixed(2);
	});
	attractorDampingSlider.addEventListener('input', (e) => { 
		ATTRACTOR_DAMPING = parseFloat(e.target.value); 
		attractorDampingLabel.textContent = ATTRACTOR_DAMPING.toFixed(2);
	});
	quantumConstantSlider.addEventListener('input', (e) => { 
		QUANTUM_CONSTANT_K = parseFloat(e.target.value); 
		quantumConstantLabel.textContent = QUANTUM_CONSTANT_K.toFixed(1);
	});
	repulsionForceSlider.addEventListener('input', (e) => { 
		REPULSION_FORCE_MAGNITUDE = parseFloat(e.target.value); 
		repulsionForceLabel.textContent = REPULSION_FORCE_MAGNITUDE.toFixed(4);
	});
	lpRepulsionMultiplierSlider.addEventListener('input', (e) => { 
		LONE_PAIR_REPULSION_MULTIPLIER = parseFloat(e.target.value); 
		lpRepulsionMultiplierLabel.textContent = LONE_PAIR_REPULSION_MULTIPLIER.toFixed(2);
	});
	coreElectronCountSlider.addEventListener('input', (e) => { 
		CORE_ELECTRON_COUNT = parseInt(e.target.value); 
		coreElectronCountLabel.textContent = CORE_ELECTRON_COUNT;
	});


	// Color pickers
	valenceColorPicker.addEventListener('change', (e) => { VALENCE_COLOR.set(e.target.value); });
	coreColorPicker.addEventListener('change', (e) => { CORE_COLOR.set(e.target.value); });
	bondColorPicker.addEventListener('change', (e) => { BOND_COLOR.set(e.target.value); });


	const moleculeSelector = document.getElementById('moleculeSelector');
	moleculeSelector.addEventListener('change', (e) => {
		loadMolecule(e.target.value);
	});
}

/**
 * Resets the simulation to its initial state:
 * - Deactivates simulation, clears angle display.
 * - Resets nuclei positions to their initial configuration and clears their velocities.
 * - Randomizes electron particle positions and clears their velocities.
 */
function resetSimulation() {
	simulationActive = false;
	document.getElementById('angleDisplay').textContent = '';
	
	currentConfig.attractorData.forEach((_, i) => {
		// Use a clone to ensure original initialPositions are not modified
		attractors[i].pos.copy(currentConfig.initialPositions[i].clone()); 
		attractors[i].vel.set(0,0,0);
	});
	// Sync visual meshes with reset positions
	attractors.forEach((a, i) => attractorMeshes[i].position.copy(a.pos));

	// Randomize particle positions for the electron cloud
	const posAttr = particleSystem.geometry.getAttribute('position');
	for (let i = 0; i < NUM_PARTICLES; i++) {
		posAttr.setXYZ(i, (Math.random()-0.5)*LENGHT, (Math.random()-0.5)*LENGHT, (Math.random()-0.5)*LENGHT);
		const ix = i * 3; 
		velocities[ix] = velocities[ix+1] = velocities[ix+2] = 0; // Reset particle velocities
	}
	posAttr.needsUpdate = true;
}

window.addEventListener('load', init);
	</script>
</body>
</html>